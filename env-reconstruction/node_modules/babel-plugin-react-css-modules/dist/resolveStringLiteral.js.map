{"version":3,"sources":["../src/resolveStringLiteral.js"],"names":["path","styleModuleImportMap","sourceAttribute","destinationName","options","resolvedStyleName","value","destinationAttribute","node","openingElement","attributes","find","attribute","name","expression","Error","splice","indexOf"],"mappings":";;;;;;AAEA;;AAMA;;;;AACA;;;;;;AAUA;;;kBAGe,CACbA,IADa,EAEbC,oBAFa,EAGbC,eAHa,EAIbC,eAJa,EAKbC,OALa,KAKkB;AAC/B,QAAMC,oBAAoB,4BAAaH,gBAAgBI,KAAhB,CAAsBA,KAAnC,EAA0CL,oBAA1C,EAAgEG,OAAhE,CAA1B;;AAEA,QAAMG,uBAAuBP,KAAKQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAC1BC,IAD0B,CACpBC,SAAD,IAAe;AACnB,WAAO,OAAOA,UAAUC,IAAjB,KAA0B,WAA1B,IAAyCD,UAAUC,IAAV,CAAeA,IAAf,KAAwBV,eAAxE;AACD,GAH0B,CAA7B;;AAKA,MAAII,oBAAJ,EAA0B;AACxB,QAAI,iCAAgBA,qBAAqBD,KAArC,CAAJ,EAAiD;AAC/CC,2BAAqBD,KAArB,CAA2BA,KAA3B,IAAoC,MAAMD,iBAA1C;AACD,KAFD,MAEO,IAAI,0CAAyBE,qBAAqBD,KAA9C,CAAJ,EAA0D;AAC/DC,2BAAqBD,KAArB,CAA2BQ,UAA3B,GAAwC,qCACtCP,qBAAqBD,KAArB,CAA2BQ,UADW,EAEtC,+BAAcT,iBAAd,CAFsC,CAAxC;AAID,KALM,MAKA;AACL,YAAM,IAAIU,KAAJ,CAAU,gCAAgCR,qBAAqBD,KAA/D,CAAN;AACD;;AAEDN,SAAKQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCM,MAApC,CAA2ChB,KAAKQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCO,OAApC,CAA4Cf,eAA5C,CAA3C,EAAyG,CAAzG;AACD,GAbD,MAaO;AACLA,oBAAgBW,IAAhB,CAAqBA,IAArB,GAA4BV,eAA5B;AACAD,oBAAgBI,KAAhB,CAAsBA,KAAtB,GAA8BD,iBAA9B;AACD;AACF,C","file":"resolveStringLiteral.js","sourcesContent":["// @flow\n\nimport {\n  isJSXExpressionContainer,\n  isStringLiteral,\n  JSXAttribute,\n  stringLiteral\n} from 'babel-types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport getClassName from './getClassName';\nimport type {\n  StyleModuleImportMapType,\n  HandleMissingStyleNameOptionType\n} from './types';\n\ntype OptionsType = {|\n  handleMissingStyleName: HandleMissingStyleNameOptionType\n|};\n\n/**\n * Updates the className value of a JSX element using a provided styleName attribute.\n */\nexport default (\n  path: *,\n  styleModuleImportMap: StyleModuleImportMapType,\n  sourceAttribute: JSXAttribute,\n  destinationName: string,\n  options: OptionsType): void => {\n  const resolvedStyleName = getClassName(sourceAttribute.value.value, styleModuleImportMap, options);\n\n  const destinationAttribute = path.node.openingElement.attributes\n    .find((attribute) => {\n      return typeof attribute.name !== 'undefined' && attribute.name.name === destinationName;\n    });\n\n  if (destinationAttribute) {\n    if (isStringLiteral(destinationAttribute.value)) {\n      destinationAttribute.value.value += ' ' + resolvedStyleName;\n    } else if (isJSXExpressionContainer(destinationAttribute.value)) {\n      destinationAttribute.value.expression = conditionalClassMerge(\n        destinationAttribute.value.expression,\n        stringLiteral(resolvedStyleName)\n      );\n    } else {\n      throw new Error('Unexpected attribute value:' + destinationAttribute.value);\n    }\n\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(sourceAttribute), 1);\n  } else {\n    sourceAttribute.name.name = destinationName;\n    sourceAttribute.value.value = resolvedStyleName;\n  }\n};\n"]}