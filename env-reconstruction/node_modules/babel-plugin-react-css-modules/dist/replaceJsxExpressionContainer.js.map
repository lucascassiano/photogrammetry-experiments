{"version":3,"sources":["../src/replaceJsxExpressionContainer.js"],"names":["t","path","sourceAttribute","destinationName","importedHelperIndentifier","styleModuleImportMapIdentifier","options","expressionContainerValue","value","destinationAttribute","node","openingElement","attributes","find","attribute","name","splice","indexOf","args","expression","handleMissingStyleName","optionsDefaults","push","styleNameExpression","callExpression","clone","stringLiteral","Error"],"mappings":";;;;;;AACA;;;;AAaA;;;;AACA;;;;AACA;;;;;;kBAMe,CACbA,CADa,EAGbC,IAHa,EAIbC,eAJa,EAKbC,eALa,EAMbC,yBANa,EAObC,8BAPa,EAQbC,OARa,KASJ;AACT,QAAMC,2BAA2BL,gBAAgBM,KAAjD;AACA,QAAMC,uBAAuBR,KAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAC1BC,IAD0B,CACpBC,SAAD,IAAe;AACnB,WAAO,OAAOA,UAAUC,IAAjB,KAA0B,WAA1B,IAAyCD,UAAUC,IAAV,CAAeA,IAAf,KAAwBZ,eAAxE;AACD,GAH0B,CAA7B;;AAKA,MAAIM,oBAAJ,EAA0B;AACxBR,SAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cf,KAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4CR,oBAA5C,CAA3C,EAA8G,CAA9G;AACD;;AAEDR,OAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cf,KAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4Cf,eAA5C,CAA3C,EAAyG,CAAzG;;AAEA,QAAMgB,OAAO,CACXX,yBAAyBY,UADd,EAEXd,8BAFW,CAAb;;AAKA;AACA;AACA,MAAIC,QAAQc,sBAAR,KAAmCC,0BAAgBD,sBAAvD,EAA+E;AAC7EF,SAAKI,IAAL,CAAU,sCAAuBtB,CAAvB,EAA0BM,OAA1B,CAAV;AACD;;AAED,QAAMiB,sBAAsBvB,EAAEwB,cAAF,CAC1BxB,EAAEyB,KAAF,CAAQrB,yBAAR,CAD0B,EAE1Bc,IAF0B,CAA5B;;AAKA,MAAIT,oBAAJ,EAA0B;AACxB,QAAI,iCAAgBA,qBAAqBD,KAArC,CAAJ,EAAiD;AAC/CP,WAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,8BACvC,+BAAcnB,eAAd,CADuC,EAEvC,wCACE,kCACE,GADF,EAEEH,EAAE0B,aAAF,CAAgBjB,qBAAqBD,KAArB,CAA2BA,KAA3B,GAAmC,GAAnD,CAFF,EAGEe,mBAHF,CADF,CAFuC,CAAzC;AAUD,KAXD,MAWO,IAAI,0CAAyBd,qBAAqBD,KAA9C,CAAJ,EAA0D;AAC/DP,WAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,8BACvC,+BAAcnB,eAAd,CADuC,EAEvC,wCACE,qCACEM,qBAAqBD,KAArB,CAA2BW,UAD7B,EAEEI,mBAFF,CADF,CAFuC,CAAzC;AASD,KAVM,MAUA;AACL,YAAM,IAAII,KAAJ,CAAU,iCAAiClB,qBAAqBD,KAAhE,CAAN;AACD;AACF,GAzBD,MAyBO;AACLP,SAAKS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,8BACvC,+BAAcnB,eAAd,CADuC,EAEvC,wCACEoB,mBADF,CAFuC,CAAzC;AAMD;AACF,C","file":"replaceJsxExpressionContainer.js","sourcesContent":["// @flow\nimport BabelTypes, {\n  binaryExpression,\n  Identifier,\n  isJSXExpressionContainer,\n  isStringLiteral,\n  jSXAttribute,\n  JSXAttribute,\n  jSXExpressionContainer,\n  jSXIdentifier\n} from 'babel-types';\nimport type {\n  HandleMissingStyleNameOptionType\n} from './types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport createObjectExpression from './createObjectExpression';\nimport optionsDefaults from './schemas/optionsDefaults';\n\ntype OptionsType = {|\n  handleMissingStyleName: HandleMissingStyleNameOptionType\n|};\n\nexport default (\n  t: BabelTypes,\n  // eslint-disable-next-line flowtype/no-weak-types\n  path: Object,\n  sourceAttribute: JSXAttribute,\n  destinationName: string,\n  importedHelperIndentifier: Identifier,\n  styleModuleImportMapIdentifier: Identifier,\n  options: OptionsType\n): void => {\n  const expressionContainerValue = sourceAttribute.value;\n  const destinationAttribute = path.node.openingElement.attributes\n    .find((attribute) => {\n      return typeof attribute.name !== 'undefined' && attribute.name.name === destinationName;\n    });\n\n  if (destinationAttribute) {\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(destinationAttribute), 1);\n  }\n\n  path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(sourceAttribute), 1);\n\n  const args = [\n    expressionContainerValue.expression,\n    styleModuleImportMapIdentifier\n  ];\n\n  // Only provide options argument if the options are something other than default\n  // This helps save a few bits in the generated user code\n  if (options.handleMissingStyleName !== optionsDefaults.handleMissingStyleName) {\n    args.push(createObjectExpression(t, options));\n  }\n\n  const styleNameExpression = t.callExpression(\n    t.clone(importedHelperIndentifier),\n    args\n  );\n\n  if (destinationAttribute) {\n    if (isStringLiteral(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier(destinationName),\n        jSXExpressionContainer(\n          binaryExpression(\n            '+',\n            t.stringLiteral(destinationAttribute.value.value + ' '),\n            styleNameExpression\n          )\n        )\n      ));\n    } else if (isJSXExpressionContainer(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier(destinationName),\n        jSXExpressionContainer(\n          conditionalClassMerge(\n            destinationAttribute.value.expression,\n            styleNameExpression\n          )\n        )\n      ));\n    } else {\n      throw new Error('Unexpected attribute value: ' + destinationAttribute.value);\n    }\n  } else {\n    path.node.openingElement.attributes.push(jSXAttribute(\n      jSXIdentifier(destinationName),\n      jSXExpressionContainer(\n        styleNameExpression\n      )\n    ));\n  }\n};\n"]}